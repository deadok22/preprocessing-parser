\clearpage

\section{Реализация библиотеки для создания синтаксических анализаторов}
\label{sec:parserlibimpl}

Реализация библиотеки для создания синтаксических анализаторов исходного кода, содержащего инструкции препроцессора, имеет следующие цели:

\begin{itemize}
\item Проверить возможность применения алгоритма, описанного в подразделе \ref{subsec:earleymodification};
\item Предоставить удобный способ реализации синтаксических анализаторов исходного кода, содержащего инструкции препроцессора, лишенный недостатков аналогов, описанных в \ref{subsec:solutionsadaptation}.
\end{itemize}

Библиотека была реализована на языке Java и имеет в своей основе двухэтапный подход, описанный в подразделе \ref{subsec:commonideas}. 

\subsection{Препроцессирующий лексер}

Первым шагом, необходимым для анализа исходного кода, содержащего инструкции препроцессора, является частичное препроцессирование и выделение лексем. Алгоритм работы препроцессирующего лексера, реализованного в этой библиотеке описан в подразделе \ref{subsubsec:configurationpreservinglexing}.

Препроцессирующий лексер абстрагируется от конкретного используемого препроцессора при помощи интерфейсов для парсера языка препроцессора и узлов AST языка препроцессора, включающего в себя узлы, соответствующие:

\begin{itemize}
\item Условной компиляции;
\item Объявлению макроопределения;
\item Удалению объявления макроопределения (\#undef);
\item Включению файла;
\item Любым другим типам узлов.
\end{itemize}

Помимо этого, выделены интерфейсы для лексера языка программирования, парсеров вызовов макроопределений, файлов с исходным кодом (они используются для разрешения имён включеных файлов), условий наличия.

Такой набор абстракций позволяет избавить пользователя библиотеки от необходимости самостоятельно реализовывать препроцессирующий лексер, сохраняющий конфигурацию.

Результатом работы препроцессирующего лексера является граф лексем и ветвлений, соответствующих явным ветвям условной компиляции.

\subsection{Парсер, сохраняющий конфигурацию}

Как было замечено ранее, алгоритм, описанный в подразделе \ref{subsec:earleymodification}, использует только грамматику языка для синтаксического анализа графа лексем, полученного на предыдущем этапе разбора. Разработанная библиотека позволяет описывать грамматику языка, используя нотацию BNF, описанную в \cite{cfg}, что приводит к возможности простого и интуитивно понятного описания грамматики языка  (см. \autoref{plus-grammar}).

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Пример описания грамматики простого языка.},label=plus-grammar,language=Java]
public final class PlusLanguage {
	//terminals
	public static final Integer INT = 0;
	public static final Integer PLUS = 1;
	//nonterminals
	public static final String EXPR = "expression";
	
	private PlusLanguage() {
	}

	public static EarleyGrammar createGrammar() {
		return EarleyGrammarBuilder.grammar(EXPR)

			.rule(EXPR).terminal(INT)
				   .completeRule()

			.rule(EXPR).nonTerminal(EXPR)
				   .terminal(PLUS)
				   .terminal(INT)
				   .completeRule()

			.build();
	}
}
\end{lstlisting}
\end{minipage}

Используя такое описание грамматики входного языка и входной граф лексем, алгоритм строит абстрактное синтаксическое дерево, содержащее узлы нескольких типов:

\begin{itemize}
\item Альтернативы --- соответствует точке ветвления для различных вариантов разбора;
\item Условная ветвь --- соответствует варианту синтаксического разбора для некоторой ветви условной компиляции;
\item Лист --- соответствует терминальным символам;
\item Композит --- соответствует нетерминальным символам.
\end{itemize}

Основное отличие от синтаксических деревьев, применяемых при синтаксическом анализе исходного кода, не содержащего инструкции препроцессора, состоит в том, что вместо любой последовательности дочерних вершин вершины композитного типа может присутствовать вершина типа альтернативы. Таким образом, выбирая обход для нужных условий наличия, можно получить дерево разбора, которое было бы получено для некоторой конкретной конфигурации препроцессора.

