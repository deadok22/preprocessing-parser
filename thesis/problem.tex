\clearpage

\section{Постановка и анализ задачи}

Проблема синтаксического разбора непрепроцессированного кода поднимается в различных публикациях уже достаточно продолжительное время. Это связано в первую очередь с большой популярностью языка С и, соответственно, его препроцессора - cpp. Далее будет описана основная функциональность препроцессора cpp и подходы к анализу непрепроцессированного кода.

\subsection{Описание функциональности препроцессора}

Препроцессор cpp предоставляет следующую функциональность: включение файлов с исходным кодом (посредством директив \#include), объявление и использование макроопределений (\#define), условная компиляция основанная на статических условиях (директивы \#if, \#ifdef, \#ifndef, и т. д.).

\todo{добавь сюда пример кода на С с условной компиляцией}

Как видно из примера, \todo{что-то типа "в зависимости от того объявлено ли макроопределение ..."}, результатом обработки исходного кода препроцессором могут быть два различных варианта программы. Набор предзаданных макроопределений позволяет выбрать единственный вариант программы на языке С, который впоследствии подаётся на вход транслятору. Далее такой набор определений будем называть конфигурацией препроцессора.

Ясно, что программист, редактируя исходный код с инструкциями препроцессора, может производить изменения одновременно в огромном количестве программ, получаемых в различных конфигурациях, что зачастую приводит к ошибкам\cite{ribeiro}. Обнаружение ошибок и другие задачи, связанные с обработкой непрепроцессированного исходного кода требуют рассмотрения сразу нескольких возможных конфигураций препроцессора.

\subsection{Обзор способов разбора непрепроцессированного кода}
\label{subsec:unpreprocessed_parsing_methods}

Существует несколько подходов к анализу непрепроцессированного кода с учётом конфигураций препроцессора.

\begin{enumerate}

\item 

Обработка конфигураций "по одной". Идея подхода в том, чтобы производить поиск ошибок и решать другие задачи обработки исходного кода в каждой конфигурации препроцессора по отдельности. Подход очень прост в реализации, он применяется как неявно - при сборке проектов с разными конфигурациями, так и явно - например, в средах разработки Xcode\footnote{\url{https://developer.apple.com/xcode/}} и KDevelop\footnote{\url{http://kdevelop.org/}}.

Однако, использование этого подхода позволяет охватывать проекты целиком, так как большие проекты содержат огромное количество конфигураций. Например, сборка ядра Linux\footnote{\url{https://www.kernel.org/}} требует установки значений более 10000 макроопределений\cite{typechef}, что исключает возможность использования такого подхода для исчерпывающего анализа кода.

\item

Применение эвристик, основанных на типичных случаях использования препроцессора. Подход состоит в том, чтобы частично интерпретировать инструкции препроцессора, получая некоторое представление исходного кода с информацией о его вариантах в разных конфигурациях. Использование такого метода не позволяет обрабатывать код полностью, так как обработка всех возможных вариантов взаимодействия инструкций препроцессора с конструкциями языка программирования не представляется возможной.

Тем не менее, этот подход позволяет достичь удовлетворительных результатов в некоторых задачах. Так, например, в Eclipse CDT\footnote{\url{http://www.eclipse.org/cdt/}} --- интегрированной среде разработки для языков С и С++ --- реализована подсветка синтаксиса и рефакторинги, учитывающие некоторые случаи использования препроцессора.

\item

Построение графа, содержащего исходный код для всех возможных конфигураций препроцессора. Идея этого метода состоит в том, чтобы неявно построить абстрактные синтаксические деревья для всех возможных конфигураций препроцессора. Таким неявным представлением является направленный ациклический граф, в котором каждой возможной конфигурации препроцессора соответствует некоторый путь из истока в сток. Подобные структуры данных применяются для хранения результатов синтаксического анализа текстов на языках, содержащих неоднозначности\cite{parseforests}.

\end{enumerate}

Несмотря на очевидные преимущества третьего подхода над первыми двумя, он очень редко применяется на практике. Отчасти это связано с высокой трудоёмкостью его реализации.

\subsection{Цель работы}

При рассмотрении существующих подходов к задаче синтаксического анализа исходного кода, содержащего инструкции препроцессора, выяснилось, что подходы, приводящие к хорошим результатам, используют лишь знание о синтаксисе языка препроцессора, семантике инструкций препроцессора и синтаксисе языка программирования в том или ином виде.

Это наблюдение привело к предположению о возможности создания инструмента, позволяющего производить синтаксический анализ исходного кода, содержащего инструкции препроцессора, используя парсер, либо грамматику языка программирования, парсера препроцессора и некоторого интерпретатора его инструкций.

Целью настоящей работы является создание такого инструмента.

\subsection{Задачи работы}

Для достижения поставленной цели необходимо решить следующие задачи:

\begin{itemize}

\item изучить существующие решения задачи синтаксического разбора непрепроцессированного кода;

\item разработать алгоритм, позволяющий использовать готовый синтаксический анализатор, либо грамматику языка программирования, для синтаксического анализа исходного кода, содержащего инструкции препроцессора;

\item реализовать разработанный алгоритм;

\item реализовать синтаксический анализатор для языка Erlang с инструкциями препроцессора, использующий разработанный алгоритм.

\end{itemize}




