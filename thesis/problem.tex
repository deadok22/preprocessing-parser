\clearpage

\section{Постановка и анализ задачи}

Проблема синтаксического разбора непрепроцессированного кода поднимается в различных публикациях уже достаточно продолжительное время. Это связано в первую очередь с большой популярностью языка С и, соответственно, его препроцессора --- cpp. Далее будет описана основная функциональность препроцессора cpp и подходы к анализу непрепроцессированного кода.

\subsection{Описание функциональности препроцессора}

Препроцессор cpp предоставляет следующую функциональность: 

\begin{itemize}
\item Включение файлов с исходным кодом посредством директив \#include; 
\item Объявление и использование макроопределений (\#define); 
\item Условную компиляцию основанную на статических условиях (директивы \#if, \#ifdef, \#ifndef, и т. д.).
\end{itemize}

Как видно из примера, приведенного в листинге \ref{conditionallogging}, результатом обработки входного файла препроцессором могут являться различные варианты исходного кода на языке С. 

Набор предзаданных макроопределений позволяет выбрать единственный вариант программы, который впоследствии подаётся на вход транслятору. Далее такой набор определений и окружение, используемое для разрешения имён включаемых файлов, будем называть конфигурацией препроцессора.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Условная компиляция},label=conditionallogging,language=C,basicstyle=\small]
#ifdef ENABLE_LOGGING 
#include <stdio.h>
#define LOG(WHAT) printf("%d:%s\n", __LINE__, WHAT)
#else
#define LOG(WHAT) 
#endif

int main(int argc, char ** argv) {
	LOG("Terminating...");
	return 0;	
}
\end{lstlisting}
\end{minipage}

Ясно, что программист, редактируя исходный код с инструкциями препроцессора, может производить изменения одновременно в огромном количестве программ, получаемых в различных конфигурациях, что зачастую приводит к ошибкам \cite{ribeiro}. Обнаружение ошибок и другие задачи, связанные с обработкой непрепроцессированного исходного кода требуют рассмотрения сразу нескольких возможных конфигураций препроцессора.

\subsection{Обзор способов разбора непрепроцессированного кода}
\label{subsec:unpreprocessed_parsing_methods}

Существует несколько подходов к анализу непрепроцессированного кода с учётом конфигураций препроцессора.

\begin{enumerate}

\item 

Обработка конфигураций <<по одной>>. Идея подхода в том, чтобы производить поиск ошибок и решать другие задачи обработки исходного кода в каждой конфигурации препроцессора по отдельности. Подход очень прост в реализации, он применяется как неявно --- при сборке проектов с разными конфигурациями, так и явно --- например, в средах разработки Xcode\footnote{\url{https://developer.apple.com/xcode/}} и KDevelop\footnote{\url{http://kdevelop.org/}}.

Однако, использование этого подхода не позволяет охватывать проекты целиком, так как большие проекты содержат огромное количество конфигураций. Например, сборка ядра Linux\footnote{\url{https://www.kernel.org/}} требует установки значений более 10000 макроопределений \cite{typechef}, что исключает возможность использования такого подхода для исчерпывающего анализа кода.

\item

Применение эвристик, основанных на типичных случаях использования препроцессора. Подход состоит в том, чтобы частично интерпретировать инструкции препроцессора, получая некоторое представление исходного кода с информацией о его вариантах в разных конфигурациях. 

Использование такого метода не позволяет обрабатывать код полностью, так как обработка всех возможных вариантов взаимодействия инструкций препроцессора с конструкциями языка программирования не представляется возможной.

Тем не менее, этот подход позволяет достичь удовлетворительных результатов в некоторых задачах. Так, например, в Eclipse CDT\footnote{\url{http://www.eclipse.org/cdt/}} --- интегрированной среде разработки для языков С и С++ --- реализована подсветка синтаксиса и рефакторинги, учитывающие некоторые случаи использования препроцессора.

\item

Построение графа, содержащего исходный код для всех возможных конфигураций препроцессора. Идея этого метода состоит в том, чтобы построить абстрактные синтаксические деревья для всех возможных конфигураций препроцессора. 

Количество деревьев разбора для всех возможных конфигураций препроцессора может экспоненциально зависеть от количества переменных в конфигурации. По этой причине построение деревьев в явном виде становится невозможным, и используются некоторые способы неявного представления леса разбора.

Одним из возможных таких представлений является направленный ациклический граф, в котором каждой возможной конфигурации препроцессора соответствует некоторый путь из истока в сток. Подобные структуры данных применяются для хранения результатов синтаксического анализа текстов на языках, содержащих неоднозначности \cite{parseforests}.

\end{enumerate}

Несмотря на очевидные преимущества третьего подхода над первыми двумя, он очень редко применяется на практике. Отчасти это связано с высокой трудоёмкостью его реализации.

\subsection{Цель работы}

При рассмотрении существующих подходов к решению задачи синтаксического анализа исходного кода, содержащего инструкции препроцессора, было замечено, что и в случае построения графа, содержащего исходный код для всех возмождных конфигураций препроцессора, и в случае разбора конфигураций <<по одной>>, используется только знание о синтаксисе языка препроцессора, его семантике, а также синтаксисе языка программирования.

Это наблюдение привело к предположению о возможности создания инструмента, позволяющего производить синтаксический анализ исходного кода, содержащего инструкции препроцессора, используя парсер, либо грамматику языка программирования, парсер для языка препроцессора препроцессора и интерпретатор его инструкций.

Целью настоящей работы является создание такого инструмента.

\subsection{Задачи работы}

Для достижения поставленной цели необходимо решить следующие задачи:

\begin{itemize}

\item изучить существующие решения задачи синтаксического разбора непрепроцессированного кода;

\item разработать алгоритм, позволяющий использовать готовый синтаксический анализатор, либо грамматику языка программирования, для синтаксического анализа исходного кода, содержащего инструкции препроцессора;

\item реализовать разработанный алгоритм;

\item реализовать синтаксический анализатор для подмножества языка Erlang с инструкциями препроцессора, использующий разработанный алгоритм.

\end{itemize}
