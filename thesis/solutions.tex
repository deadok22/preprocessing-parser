\clearpage

\section{Существующие решения}

Этот раздел содержит подробности реализаций подхода к решению проблемы синтаксического анализа непрепроцессированного исходного кода, состоящего в построении графа, содержащего все варианты препроцессированного исходного кода (см. описание подхода в подразделе \ref{subsec:unpreprocessed_parsing_methods}).

Наиболее известными реализациями этого подхода являются SuperC\cite{superc} и TypeChef\cite{typechef}.

\subsection{Общие идеи}

Построение графа, содержащего абстрактные синтаксические деревья для всех конфигураций препроцессора, так или иначе включает в себя два этапа:

\begin{enumerate}

\item Лексический анализ, сохраняющий конфигурацию;
\item Синтаксический анализ, сохраняющий конфигурацию;

\end{enumerate} 

\subsubsection{Лексический анализ, сохраняющий конфигурацию}

Работа, выполняемая на этом этапе, условно состоит из двух частей - интерпретации инструкций препроцессора и проведения лексического анализа входного текста. Условность здесь состоит в том, что эти части могут выполняться одновременно, если языком препроцессора используются те же лексемы, что и языком программирования.

Инструкции препроцессора интерпретируются аналогично тому, как это делает сам препроцессор, за тем исключением, что строятся варианты выходных последовательностей одновременно для всех конфигураций. Более подробно работа лексического анализатора, сохраняющего конфигурацию описана в подразделе \todo{добавить сюда референс на описание работы препроцессирующего лексера SuperC}.

Результатом выполнения этого этапа является последовательность лексем и узлов условного ветвления, представленная в том или ином виде. Узлы ветвления представляют собой наборы из подпоследовательностей лексем и узлов условного ветвления, предваренных так называемыми условиями наличия (presence conditions). Каждый такой набор внутри узла ветвления соответствует некоторой альтернативной ветви условной компиляции в исходном непрепроцессированном коде.

\subsubsection{Синтаксический анализ, сохраняющий конфигурацию}

Этот этап состоит в преобразовании входной последовательности из лексем и узлов условного ветвления в абстрактное синтаксическое дерево (либо абстрактный синтаксический лес), содержащий вершины, соответствующие конструкциям языка программирования, как в обыкновенном абстрактном синтаксическом дереве, а также вершины условного ветвления, каждая ветвь которых соответствует некоторой альтернативной ветви условной компиляции.

Появление узла ветвления во входной последовательности лексем может приводить к различной интерпретации лексем, предшествующих текущей. \todo{Это ясно, или нужен пример?} Это может привнести существенные сложности при разборе альтернативных ветвей условной компиляции.

Помимо проблемы выбора места ветвления, имеет место проблема выбора места слияния. Она состоит в том, что лексемы, следующие за узлом условного ветвления могут быть проинтерпретированы по-разному для каждой из альтернативных ветвей.

Слишком раннее ветвление, равно как и слишком позднее слияние могут привести к многократному парсингу одних и тех же участков кода, что приводит к существенному снижению производительности.
