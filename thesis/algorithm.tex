\clearpage

\section{Синтаксический анализ непрепроцессированного кода}

В этом разделе описывается алгоритм, позволяющий производить синтаксический анализ исходного кода, представленного в виде графа лексем и точек ветвлений (см. подраздел \ref{subsubsec:configurationpreservinglexing}).

\subsection{Мотивация}

Для построения графа синтаксического разбора, содержащего деревья разбора для всех возможных конфигураций препроцессора, необходимо некоторое знание о структуре языка, либо о синтаксическом анализаторе, используемом для разбора языка программирования.

В проектах SuperC и TypeChef использовалось знание о синтаксических анализаторах. А именно, SuperC использует LR-действия синтаксического анализатора языка программирования в явном виде, TypeChef же предлагает использовать свои инструменты для создания синтаксического анализатора языка программирования. Первое решение основывается на LR-анализаторах, второе - на LL, - и в первом и во втором случае может потребоваться модификация грамматики языка программирования, с тем, чтобы удовлетворить ограничения на обрабатываемые языки, накладываемые этими классакми парсеров.

Результатом такого выбора стала высокая трудоёмкость адаптации этих решений для работы с другими языками программирования (см. подраздел \ref{subsec:solutionsadaptation}).

Поэтому к алгоритму синтаксического анализа непрепроцессированного кода, разрабатываемому в настоящей работе, предъявляются следующие требования:

\begin{itemize}
\item Использование только грамматики языка программирования;
\item Возможность синтаксического анализа исходного кода на любых языках, описываемых контекстно-свободными грамматиками\cite{cfg}.
\end{itemize}

Для удовлетворения данных требований был разработан универсальный алгоритм синтаксического анализа, основанный на алгоритме Earley\cite{earley68}.

\subsection{Алгоритм Earley}
Алгоритм синтаксического анализа Earley напрямую использует грамматику языка программирования и позволяет производить разбор текстов на языках, содержащих неоднозначности.

Результатом работы алгоритма является последовательность состояний, по которой можно определить принадлежность входного текста языку, а также восстановить все возможные деревья разбора. Далее будет описан сам алгоритм.

Как уже было замечено ранее, алгоритм строит последовательность некоторых состояний. Каждое состояние соответствует входной лексеме, для которой это состояние было получено и представляет собой упорядоченное множество элементов Эрли (Earley item). Элемент Эрли представляет собой продукцию грамматики с индексом в ней, обозначающимся точкой. Например, $A \to \cdot B$, $A \to B \cdot $, $A \to x \cdot B$. Часть продукции слева от точки - уже совпала со входом, а часть справа соответствует ожидаемому входу. Кроме этого, в элементе Эрли сохраняется номер состояния первого появления этого элемента.

На каждом шаге алгоритм заполняет текущее состояние и инициирует следующее. Первое состояние алгоритма инициализируется элементами Эрли, соответствующими начальному символу грамматики с точкой перед телом продукции. Рассмотрим теперь каким образом завершается состояние $n$ и инициируется состояние $n+1$. Производятся три операции:

\begin{itemize}

\item Предсказание. Для каждого элемента Эрли из состояния $n$, имеющего нетерминал после точки, в состояние $n$ добавляются элементы Эрли, соответствующие всем продукциям грамматики для этого нетерминала, с точками перед телами продукций.

\item Сканирование. Для каждого элемента Эрли из состояния $n$, имеющего терминал после точки, совпадающий с входной лексемой на этом шаге, в состояние $n+1$ добавляется элемент Эрли, с точкой сдвинутой за поглощенный терминал.

\item Завершение. Эта операция производится для каждого элемента Эрли из состояния $n+1$, в котором точка находится после тела продукции, - это соответствует окончанию сопоставления продукции тексту. Если элемент Эрли соответствует продукции для некоторого нетерминала $A$, то производится поиск продукций, имеющих точку перед этим нетерминалом в состоянии, соответствующем первому появлению текущего элемента. В состояние $n+1$ добавляются элементы Эрли, соответствующие поглощенному нетерминалу $A$.

\end{itemize}

Так, результатом работы алгоритма станет последовательность из $N+1$ состояния для входного текста длины $N$ лексем. Если входной текст принадлежит языку, грамматика которого использовалась для разбора, то в последнем состоянии будет находиться хотя бы один завершенный элемент Эрли, впервые добавленный в первом состоянии, соответствующий начальному символу грамматики.

Описанный выше алгоритм производит только распознавание входа, т. е. позволяет определить принадлежит ли входной текст языку, описываемому используемой грамматикой. Несколько модифицировав алгоритм распознавания, можно получить средство для восстановления деревьев разбора. Для этого необходимо при выполнении сканирования и завершения сохранять указатели/ссылки на элементы Эрли, из которых мог быть быть получен новый элемент Эрли. Обратный проход по этим указателям, начиная с состояния, соответствующего начальному символу, будет соответствовать одному из возможных деревьев разбора. Более подробно о преобразовании алгоритма распознавания в парсер можно прочесть в оригинальной работе \cite{earley68}, а также в \cite{recognizertoparser}.

Замечательная особенность алгоритма состоит в том, что он работает с любой контекстно-свободной грамматикой и не требует её приведения к какому-либо специальному виду.

\subsection{Модификация алгоритма Earley}
