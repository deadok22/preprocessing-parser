\clearpage

\section{Синтаксический анализ непрепроцессированного кода}

В этом разделе описывается алгоритм, позволяющий производить синтаксический анализ исходного кода, представленного в виде графа лексем и точек ветвлений (см. подраздел \ref{subsubsec:configurationpreservinglexing}).

\subsection{Мотивация}

Для построения графа синтаксического разбора, содержащего деревья разбора для всех возможных конфигураций препроцессора, необходимо знание о структуре языка, либо о синтаксическом анализаторе, используемом для разбора языка программирования.

В проектах SuperC и TypeChef использовалось знание о синтаксических анализаторах. А именно, SuperC использует LR-действия синтаксического анализатора языка программирования в явном виде, TypeChef же предлагает использовать свои инструменты для создания синтаксического анализатора языка программирования. Первое решение основывается на LR-анализаторах, второе - на LL, - и в первом и во втором случае может потребоваться модификация грамматики языка программирования, с тем, чтобы удовлетворить ограничения на обрабатываемые языки, накладываемые этими классакми парсеров.

Результатом такого выбора стала высокая трудоёмкость адаптации этих решений для работы с другими языками программирования (см. подраздел \ref{subsec:solutionsadaptation}).

Поэтому к алгоритму синтаксического анализа непрепроцессированного кода, разрабатываемому в настоящей работе, предъявляются следующие требования:

\begin{itemize}
\item Использование только грамматики языка программирования;
\item Возможность синтаксического анализа исходного кода на любых языках, описываемых контекстно-свободными грамматиками \cite{cfg}.
\end{itemize}

Для удовлетворения данных требований был разработан универсальный алгоритм синтаксического анализа, основанный на алгоритме Earley \cite{earley68}.

\subsection{Алгоритм Earley}
Алгоритм синтаксического анализа Earley напрямую использует грамматику языка программирования и позволяет производить разбор текстов на языках, содержащих неоднозначности.

Результатом работы алгоритма является последовательность состояний, по которой можно определить принадлежность входного текста языку, а также восстановить все возможные деревья разбора. Далее будет описан сам алгоритм.

Как уже было замечено ранее, алгоритм строит последовательность некоторых состояний. Каждое состояние соответствует входной лексеме, для которой это состояние было получено и представляет собой упорядоченное множество элементов Earley (Earley item). Элемент Earley представляет собой продукцию грамматики с индексом в ней, обозначающимся точкой. Например, $A \to \cdot B$, $A \to B \cdot $, $A \to x \cdot B$. Часть продукции слева от точки - уже совпала со входом, а часть справа соответствует ожидаемому входу. Кроме этого, в элементе Earley сохраняется номер состояния первого появления этого элемента.

На каждом шаге алгоритм заполняет текущее состояние и инициирует следующее. Первое состояние алгоритма инициализируется элементами Earley, соответствующими начальному символу грамматики с точкой перед телом продукции. Рассмотрим теперь каким образом завершается состояние $n$ и инициируется состояние $n+1$. Производятся три операции:

\begin{itemize}

\item Предсказание. Для каждого элемента Earley из состояния $n$, имеющего нетерминал после точки, в состояние $n$ добавляются элементы Earley, соответствующие всем продукциям грамматики для этого нетерминала, с точками перед телами продукций.

\item Сканирование. Для каждого элемента Earley из состояния $n$, имеющего терминал после точки, совпадающий с входной лексемой на этом шаге, в состояние $n+1$ добавляется элемент Earley, с точкой сдвинутой за поглощенный терминал.

\item Завершение. Эта операция производится для каждого элемента Earley из состояния $n+1$, в котором точка находится после тела продукции, - это соответствует окончанию сопоставления продукции тексту. Если элемент Earley соответствует продукции для некоторого нетерминала $A$, то производится поиск продукций, имеющих точку перед этим нетерминалом в состоянии, соответствующем первому появлению текущего элемента. В состояние $n+1$ добавляются элементы Earley, соответствующие поглощенному нетерминалу $A$.

\end{itemize}

В листинге \ref{earleyrecognizer} приведена функция doEarleyStep, в которой производятся описанные выше действия.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Псевдокод шага алгоритма Earley},language=Scala,label=earleyrecognizer]
def doEarleyStep(lexeme, chart) = {
	val currentCol = chart.lastColumn
	val nextCol = chart.newColumnt
	predict(currentCol)
	scan(lexeme, currentCol, nextCol)
	complete(nextCol)
}

def predict(currentCol) = 
	currentCol.items.forEach(predictForItem(_, currentCol))

def predictForItem(item, currentColumn) = {
	if (item.isComplete || item.nextSymbol.isTerminal) return
	val productions = Grammar .productionsFor(item.nextSymbol)
	productions.forEach(production => {
		val item = currentColumn.addItem(production)
		if (item != null) predictForItem(item)
	})
}

def scan(lexeme, currentCol, nextCol) = 
	currentCol.items.filter(_.expects(lexeme))
		.forEach(nextCol.addItem(_.consume(lexeme)))
	
def complete(nextCol) = 
	nextCol.items.forEach(completeForItem(_, nextCol))

def completeForItem(item, nextCol) = {
	if (!item.isComplete) return
	item.startColumn.items.filter(_.expects(item))
		.forEach(startColItem => {
			val newItem = nextCol.addItem(startColItem.consume(item))
			if (newItem != null)
				completeForItem(newItem, nextCol)		
		})
}
\end{lstlisting}
\end{minipage}

Так, результатом работы алгоритма станет последовательность из $N+1$ состояния для входного текста длины $N$ лексем. Если входной текст принадлежит языку, грамматика которого использовалась для разбора, то в последнем состоянии будет находиться хотя бы один завершенный элемент Earley, впервые добавленный в первом состоянии, соответствующий начальному символу грамматики.

Описанный выше алгоритм производит только распознавание входа, т. е. позволяет определить принадлежит ли входной текст языку, описываемому используемой грамматикой. Несколько модифицировав алгоритм распознавания, можно получить средство для восстановления деревьев разбора.

Для этого необходимо при выполнении сканирования и завершения сохранять указатели/ссылки на элементы Earley, из которых мог быть получен новый элемент Earley (это может быть реализовано в функции consume, используемой в листинге \ref{earleyrecognizer}). 

Обратный проход по этим указателям, начиная с состояния, соответствующего завершенному разбору для начального символа, будет соответствовать одному из возможных деревьев разбора. Более подробно о преобразовании алгоритма распознавания в парсер можно прочесть в оригинальной работе \cite{earley68}, а также в \cite{recognizertoparser}.

Замечательная особенность алгоритма состоит в том, что он работает с любой контекстно-свободной грамматикой и не требует её приведения к какому-либо специальному виду.

\subsection{Модификация алгоритма Earley}
\label{subsec:earleymodification}

\todo{переделать этот текст, вставить псевдокод и т.д. и т.п.}

Далее описывается модификация алгоритма Earley, позволяющая работать с графом, полученным на выходе препроцессирующего лексера, сохраняющего конфигурацию. 

Основная идея алгоритма состоит в том, чтобы для различных ветвей условной компиляции строить различные последовательности состояний, сохраняя условия наличия, после чего объединять полученные наборы состояний.

Алгоритм начинает свою работу точно как оригинальный алгоритм распознавания Earley.

Если в процессе работы встречается точка ветвленияв графе лексем, то создаются новые распознаватели Earley для каждой из ветвей условной компиляции. В каждой ветви используется состояние, соответствующее состоянию перед точкой ветвления, в качестве начального. Далее этот же алгоритм рекурсивно обрабатывает каждую ветвь независимо (это предоставляет возможность для распараллеливания алгоритма). По завершении обработки ветвей, производится слияние последнего состояния каждой ветви в новое состояние и работа алгоритма продолжается.

Стоит заметить, что теперь элемент Earley может быть получен не только из разных предшествующих элементов Earley, но и из одних и тех же предшественников путями, отличающимися по условиями наличия.

Для корректной обработки таких случаев в элементах Earley дополнительно для каждого предшественника элемента хранится условие наличия и множество редукций, по которым этот элемент мог быть получен из предыдущего.

Под редукцией здесь понимается завершенный элемент Earley, либо терминал, находящийся слева от точки в текущем элементе Earley. В редукции также сохраняется указатель на состояние Earley, в котором был начат разбор этой редукции. Это позволяет восстанавливать все возможные способы получения данного элемента Earley, что используется при восстановлении графа разбора.

Условия наличия для элемента Earley вычисляется по-разному в зависимости от способа получения элемента. Для элементов, полученных предсказанием это условие наличия предшественника. Для элементов, полученных сканированием это логическое <<И>> условия наличия терминала и условия наличия предшественника. Для элементов, полученных завершением это логическое <<И>> условия наличия предшественника и условия наличия элемента Earley, использованного для завершения.

Как и в случае оригинального алгоритма, наличие в последнем состоянии завершенного элемента Earley, впервые появившегося в первом состоянии, будет соответствовать принадлежности исходного текста языку. Однако, следует заметить, что наличие таких элементов в последнем состоянии не означает корректности кода во всех возможных конфигурациях - ошибки разбора, связанные с ветвлениями следует отслеживать отдельно.

Далее следует описание алгоритма восстановление графа синтаксического разбора, содержащего деревья синтаксического разбора для всех возможных конфигураций препроцессора.

Суть восстановления состоит в преобразовании завершенных элементов Earley в узлы графа-результата. Такое преобразование осуществляется следующим образом:

\begin{itemize}
\item Если у элемента единственный предок, то создаётся вершина графа, соответствующая этому элементу Earley, дети этой вершины строятся для этого единственного предка;
\item Если у элемента несколько предков, то производится разрешение неопределенностей (опционально). После этого шага создаётся узел ветвления, каждая ветвь которого - подграф, построенный для одного из предков с его условием наличия, условие наличия узла ветвления - логическое <<ИЛИ>> условий наличия его ветвей.
\end{itemize}

Подграф для предка элемента Earley строится так:

\begin{enumerate}
\item Создаётся вершина, помеченная нетерминальным символом элемента Earley;
\item Строятся подграфы для детей этой вершины;
\item Условие наличия этой вершины есть конъюнкция условия наличия элемента Earley и логического <<И>> всех детей этой вершины.
\end{enumerate}

Построение подграфов для детей вершины производится рекурсивно следующим образом:

\begin{itemize}
\item Если этот элемент мог быть получен из предшественника единственной редукцией, то строится узел для этой редукции, последующие узлы строятся рекурсивно;
\item Если этот элемент мог быть получен из предшественника несколькими редукциями, то создаётся узел ветвления, каждая ветвь которого соответствует различным вариантам разбора начиная с этого потомка. Каждая ветвь строится рекурсивно.
\end{itemize}

Для функции, преобразующей завершенные элементы в узлы графа-результата разумно применять мемоизацию, так как в некоторых случаях они могут быть вызваны многократно для одних и тех же узлов.

Таким образом, модифицированный алгоритм Earley позволяет строить граф, содержащий синтаксические деревья для всех возможных конфигураций препроцессора без какой-либо дополнительной информации о возможных точках ветвления и слияния ветвей условной компиляции.

\subsubsection{Распознавание}




\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Псевдокод модифицированных процедур алгоритма Earley},language=Scala,label=modearleyprocs]
def predictForItem(item, currentColumn) = {
	if (item.predictionIsDone || item.isComplete || 
		item.nextSymbol.isTerminal) return
	item.predictionIsDone = true
	val pc = getOrOfPrsenceConditions(item, currentColumn)
	val productions = Grammar.productionsFor(item.nextSymbol)
	productions.forEach(production => {
		val item = currentColumn.addItem(production, pc)
		if (item != null)
			predictForItem(item)
	})
}

def scan(lexeme, currentCol, nextCol) = 
	currentCol.items.filter(_.expects(lexeme))
		.forEach(item => {
			val pc = item.presenceCondition and
				lexeme.presenceCondtion
			nextCol.addItem(item.consume(lexeme), pc)
		})

def completeForItem(item, nextCol) = {
	if (!item.isComplete) return
	item.startColumn.items filter(_.expects(item))
		.forEach(startColItem => {
			val pc = item.presenceCondition and 
				startColItem.presenceCondition
			val newItem = 
				nextCol.addItem(startColItem.consume(item), pc)
			if (newItem != null)
				completeForItem(newItem, nextCol)		
		})
}
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Псевдокод алгоритма распознавания},language=Scala,label=recognitionpseudocode]
def recognize(stream) : Chart = {
	val chart = new Chart
	processStream(stream, chart)
	predict(chart.lastColumn)
	complete(chart.lastColumn)
	chart
}

def processStream(stream, chart) = {
	var lexeme = stream.eof
	while ((lexeme = stream.next) != stream.eof) {
		lexeme match {
			case Fork(streams) => {
				val colBeforeFork = chart.lastColumn
				predict(colBeforeFork)
				val forkLastColumns = streams.map(
					forkStream => {
						val subChart = chart
							.subChart(forkStream.presenceCondition)
						processStream(forkStream, subChart)
						subChart.lastColumn
					}
				)
				val colAfterFork = chart.newColumn()
				forkLastColumns.forEach(colAfterFork.addItemsFrom(_))
				val orOfForkPCs = streams
					.foldLeft(PresenceCondition.False) 
						(_ or _.presenceCondition)
				if (!orOfForkPCs.isTrue) 
					colAfterFork
						.addItemsFrom(colBeforeFork, orOfForkPCs.not)
			}
			case lexeme => doEarleyStep(lexeme, chart)
		}
	}
}
\end{lstlisting}
\end{minipage}

\subsubsection{Построение графа синтаксического разбора}


